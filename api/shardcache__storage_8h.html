<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Shardcache: libshardcache/shardcache_storage.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Shardcache
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_154c52f89b78804c0b53c0039fc4a47d.html">libshardcache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">shardcache_storage.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structshardcache__storage__index__item__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#structshardcache__storage__index__item__t">shardcache_storage_index_item_t</a></td></tr>
<tr class="memdesc:structshardcache__storage__index__item__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure representing an item in the storage index  <a href="shardcache__storage_8h.html#structshardcache__storage__index__item__t">More...</a><br /></td></tr>
<tr class="separator:structshardcache__storage__index__item__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structshardcache__storage__index__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#structshardcache__storage__index__t">shardcache_storage_index_t</a></td></tr>
<tr class="memdesc:structshardcache__storage__index__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure representing the storage index, holding an array of <a class="el" href="shardcache__storage_8h.html#structshardcache__storage__index__item__t" title="structure representing an item in the storage index ">shardcache_storage_index_item_t</a> structures.  <a href="shardcache__storage_8h.html#structshardcache__storage__index__t">More...</a><br /></td></tr>
<tr class="separator:structshardcache__storage__index__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct____shardcache__storage__s"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#struct____shardcache__storage__s">shardcache_storage_t</a></td></tr>
<tr class="separator:struct____shardcache__storage__s"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structshardcache__counter__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#structshardcache__counter__t">shardcache_counter_t</a></td></tr>
<tr class="memdesc:structshardcache__counter__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing an exposed counter.  <a href="shardcache__storage_8h.html#structshardcache__counter__t">More...</a><br /></td></tr>
<tr class="separator:structshardcache__counter__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct____shardcache__storage__s_8internal"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#struct____shardcache__storage__s_8internal">__shardcache_storage_s.internal</a></td></tr>
<tr class="separator:struct____shardcache__storage__s_8internal"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a133019dc2f53df8463b3c0f3d5527f2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a133019dc2f53df8463b3c0f3d5527f2b">SHARDCACHE_STORAGE_API_VERSION</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a133019dc2f53df8463b3c0f3d5527f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a77115805f2f16c71266f6ad605cfe0fa"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a77115805f2f16c71266f6ad605cfe0fa">shardcache_fetch_item_callback_t</a>) (void *key, size_t klen, void **value, size_t *vlen, void *priv)</td></tr>
<tr class="memdesc:a77115805f2f16c71266f6ad605cfe0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to provide the value for a given key.  <a href="#a77115805f2f16c71266f6ad605cfe0fa">More...</a><br /></td></tr>
<tr class="separator:a77115805f2f16c71266f6ad605cfe0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4f7d79c1f74accc80c3e448319b576"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a9c4f7d79c1f74accc80c3e448319b576">shardcache_fetch_items_callback_t</a>) (void **keys, size_t *klens, int nkeys, void **values, size_t *vlens, void *priv)</td></tr>
<tr class="memdesc:a9c4f7d79c1f74accc80c3e448319b576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to provide values for multiple keys at once.  <a href="#a9c4f7d79c1f74accc80c3e448319b576">More...</a><br /></td></tr>
<tr class="separator:a9c4f7d79c1f74accc80c3e448319b576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996475c853ec7e30994b9ea9171e1977"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a996475c853ec7e30994b9ea9171e1977">shardcache_store_item_callback_t</a>) (void *key, size_t klen, void *value, size_t vlen, void *priv)</td></tr>
<tr class="memdesc:a996475c853ec7e30994b9ea9171e1977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to store a new value for a given key.  <a href="#a996475c853ec7e30994b9ea9171e1977">More...</a><br /></td></tr>
<tr class="separator:a996475c853ec7e30994b9ea9171e1977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0e75764a7131dc7b96a13a656be1e9"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a6a0e75764a7131dc7b96a13a656be1e9">shardcache_remove_item_callback_t</a>) (void *key, size_t klen, void *priv)</td></tr>
<tr class="memdesc:a6a0e75764a7131dc7b96a13a656be1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to remove an existing value for a given key.  <a href="#a6a0e75764a7131dc7b96a13a656be1e9">More...</a><br /></td></tr>
<tr class="separator:a6a0e75764a7131dc7b96a13a656be1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4d387c8442c3bc8828a30cac2fa351"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a0f4d387c8442c3bc8828a30cac2fa351">shardcache_exist_item_callback_t</a>) (void *key, size_t klen, void *priv)</td></tr>
<tr class="memdesc:a0f4d387c8442c3bc8828a30cac2fa351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to check if a specific key exists on the storage.  <a href="#a0f4d387c8442c3bc8828a30cac2fa351">More...</a><br /></td></tr>
<tr class="separator:a0f4d387c8442c3bc8828a30cac2fa351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4334fefdfd765ed2ed3783fd930e1eaf"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a4334fefdfd765ed2ed3783fd930e1eaf">shardcache_count_items_callback_t</a>) (void *priv)</td></tr>
<tr class="memdesc:a4334fefdfd765ed2ed3783fd930e1eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback returning the number of items in the index.  <a href="#a4334fefdfd765ed2ed3783fd930e1eaf">More...</a><br /></td></tr>
<tr class="separator:a4334fefdfd765ed2ed3783fd930e1eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fef27941beefd884ef508f09f876ad"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a72fef27941beefd884ef508f09f876ad">shardcache_get_index_callback_t</a>) (<a class="el" href="shardcache__storage_8h.html#structshardcache__storage__index__item__t">shardcache_storage_index_item_t</a> *index, size_t isize, void *priv)</td></tr>
<tr class="memdesc:a72fef27941beefd884ef508f09f876ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to fetch the index of stored keys.  <a href="#a72fef27941beefd884ef508f09f876ad">More...</a><br /></td></tr>
<tr class="separator:a72fef27941beefd884ef508f09f876ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2572426fe6ef4e4c3f3306a6e37ebd74"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a2572426fe6ef4e4c3f3306a6e37ebd74">shardcache_thread_start_callback_t</a>) (void *priv)</td></tr>
<tr class="memdesc:a2572426fe6ef4e4c3f3306a6e37ebd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to notify the underlying storage about the creation of a new worker thread.  <a href="#a2572426fe6ef4e4c3f3306a6e37ebd74">More...</a><br /></td></tr>
<tr class="separator:a2572426fe6ef4e4c3f3306a6e37ebd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0328b13b4cd837b9c8adf61a2fcac12e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a0328b13b4cd837b9c8adf61a2fcac12e">shardcache_thread_exit_callback_t</a>) (void *priv)</td></tr>
<tr class="memdesc:a0328b13b4cd837b9c8adf61a2fcac12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback returning the number of items in the index.  <a href="#a0328b13b4cd837b9c8adf61a2fcac12e">More...</a><br /></td></tr>
<tr class="separator:a0328b13b4cd837b9c8adf61a2fcac12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9c26308b738a1b3e576086739800ef"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a1b9c26308b738a1b3e576086739800ef">shardcache_storage_init_t</a>) (<a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t">shardcache_storage_t</a> *, char **)</td></tr>
<tr class="separator:a1b9c26308b738a1b3e576086739800ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5038a83d8a6632c7428a09f94822ec0a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a5038a83d8a6632c7428a09f94822ec0a">shardcache_storage_destroy_t</a>) (void *)</td></tr>
<tr class="separator:a5038a83d8a6632c7428a09f94822ec0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae614818897fc60c8474e7722d997eb62"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#ae614818897fc60c8474e7722d997eb62">shardcache_storage_reset_t</a>) (void *)</td></tr>
<tr class="separator:ae614818897fc60c8474e7722d997eb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848ddc8184ab4372f3230498bee3383e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t">shardcache_storage_t</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a848ddc8184ab4372f3230498bee3383e">shardcache_storage_constructor</a>) (const char **options)</td></tr>
<tr class="memdesc:a848ddc8184ab4372f3230498bee3383e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to create a new instance of a storage module.  <a href="#a848ddc8184ab4372f3230498bee3383e">More...</a><br /></td></tr>
<tr class="separator:a848ddc8184ab4372f3230498bee3383e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160e6e6138d57c6b6ed3c59e1a1f2578"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a160e6e6138d57c6b6ed3c59e1a1f2578">shardcache_storage_destructor</a>) (<a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t">shardcache_storage_t</a> *storage)</td></tr>
<tr class="memdesc:a160e6e6138d57c6b6ed3c59e1a1f2578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to dispose all resources associated to a previously initialized storage module.  <a href="#a160e6e6138d57c6b6ed3c59e1a1f2578">More...</a><br /></td></tr>
<tr class="separator:a160e6e6138d57c6b6ed3c59e1a1f2578"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a075b1863d2be9c8ab1a863ea860112e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#a075b1863d2be9c8ab1a863ea860112e2">shardcache_get_counters</a> (<a class="el" href="shardcache_8h.html#a32947f5c645e606fe2284a1c28f7fcf9">shardcache_t</a> *cache, <a class="el" href="shardcache__storage_8h.html#structshardcache__counter__t">shardcache_counter_t</a> **counters)</td></tr>
<tr class="memdesc:a075b1863d2be9c8ab1a863ea860112e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of registered counters with their actual value.  <a href="#a075b1863d2be9c8ab1a863ea860112e2">More...</a><br /></td></tr>
<tr class="separator:a075b1863d2be9c8ab1a863ea860112e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56ead41f7f61d7b88417fc9dc6937f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shardcache__storage_8h.html#aa56ead41f7f61d7b88417fc9dc6937f8">shardcache_clear_counters</a> (<a class="el" href="shardcache_8h.html#a32947f5c645e606fe2284a1c28f7fcf9">shardcache_t</a> *cache)</td></tr>
<tr class="memdesc:aa56ead41f7f61d7b88417fc9dc6937f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all the counters to 0.  <a href="#aa56ead41f7f61d7b88417fc9dc6937f8">More...</a><br /></td></tr>
<tr class="separator:aa56ead41f7f61d7b88417fc9dc6937f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structshardcache__storage__index__item__t" id="structshardcache__storage__index__item__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct shardcache_storage_index_item_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>structure representing an item in the storage index </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a670ba9cfd8b46b173e8e5da4e82a3b8b"></a>void *</td>
<td class="fieldname">
key</td>
<td class="fielddoc">
A valid pointer to the key. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aec24ca2e658b94af72eee3c685467072"></a>size_t</td>
<td class="fieldname">
klen</td>
<td class="fielddoc">
The length of the key. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a95c9eeb86ef6dc93bdfcc4f4b79ef5b9"></a>size_t</td>
<td class="fieldname">
vlen</td>
<td class="fielddoc">
The length of the value. </td></tr>
</table>

</div>
</div>
<a name="structshardcache__storage__index__t" id="structshardcache__storage__index__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct shardcache_storage_index_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>structure representing the storage index, holding an array of <a class="el" href="shardcache__storage_8h.html#structshardcache__storage__index__item__t" title="structure representing an item in the storage index ">shardcache_storage_index_item_t</a> structures. </p>
<dl class="section note"><dt>Note</dt><dd>Can be obtained calling <a class="el" href="shardcache_8h.html#a9d02396238920c93777e1eb2bc83dad0" title="Get the index of keys managed by the specific shardcache instance by querying the storage module...">shardcache_get_index()</a> and MUST be disposed using <a class="el" href="shardcache_8h.html#a7f3e042fe58a3dd7537c81de115bba25" title="Release all resources used by the index provided as argument. ">shardcache_free_index()</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad8fd15098581e807a536a2b087911304"></a><a class="el" href="shardcache__storage_8h.html#structshardcache__storage__index__item__t">shardcache_storage_index_item_t</a> *</td>
<td class="fieldname">
items</td>
<td class="fielddoc">
Array of <a class="el" href="shardcache__storage_8h.html#structshardcache__storage__index__item__t" title="structure representing an item in the storage index ">shardcache_storage_index_item_t</a> structures. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa721e02948c35a4e004623da64ba00db"></a>size_t</td>
<td class="fieldname">
size</td>
<td class="fielddoc">
The number of elements in the 'items' array. </td></tr>
</table>

</div>
</div>
<a name="struct____shardcache__storage__s" id="struct____shardcache__storage__s"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct __shardcache_storage_s</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="adfe6bbc8dbd37f24bb25a7aea5f0228b"></a>uint32_t</td>
<td class="fieldname">
version</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aaa00ffadd93d02ef58548c9923ee097e"></a><a class="el" href="shardcache__storage_8h.html#a77115805f2f16c71266f6ad605cfe0fa">shardcache_fetch_item_callback_t</a></td>
<td class="fieldname">
fetch</td>
<td class="fielddoc">
The fecth callback. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aaa1e644d6bc5bf96f28255f7406042cc"></a><a class="el" href="shardcache__storage_8h.html#a9c4f7d79c1f74accc80c3e448319b576">shardcache_fetch_items_callback_t</a></td>
<td class="fieldname">
fetch_multi</td>
<td class="fielddoc">
The fetch multiple items callback (XXX - still unused) </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="adac8862fb938810e5774ba08a804b2c6"></a><a class="el" href="shardcache__storage_8h.html#a996475c853ec7e30994b9ea9171e1977">shardcache_store_item_callback_t</a></td>
<td class="fieldname">
store</td>
<td class="fielddoc">
The store callback (optional if the storage is indended to be read-only) </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a6363463cd20b522ec922f8bc931d9c7f"></a><a class="el" href="shardcache__storage_8h.html#a6a0e75764a7131dc7b96a13a656be1e9">shardcache_remove_item_callback_t</a></td>
<td class="fieldname">
remove</td>
<td class="fielddoc">
The remove callback (optional if the storage is intended to be read-only) </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a977ddd05f7f5a1e30aa0b4a3d9baba6d"></a><a class="el" href="shardcache__storage_8h.html#a0f4d387c8442c3bc8828a30cac2fa351">shardcache_exist_item_callback_t</a></td>
<td class="fieldname">
exist</td>
<td class="fielddoc">
Optional callback which can be used to 'quickly' check if a key exists in the storage. <dl class="section note"><dt>Note</dt><dd>The speed of this callback strictly depends on the storage implementation </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2f958de4182b95ef054e9dff32c3c8f4"></a><a class="el" href="shardcache__storage_8h.html#a72fef27941beefd884ef508f09f876ad">shardcache_get_index_callback_t</a></td>
<td class="fieldname">
index</td>
<td class="fielddoc">
Optional callback which returns the index of keys accessible through the storage. <dl class="section note"><dt>Note</dt><dd>check <a class="el" href="shardcache_8h.html#a9d02396238920c93777e1eb2bc83dad0" title="Get the index of keys managed by the specific shardcache instance by querying the storage module...">shardcache_get_index()</a> documentation for more details </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae45d5d91431a9b09213c43192851ab91"></a><a class="el" href="shardcache__storage_8h.html#a4334fefdfd765ed2ed3783fd930e1eaf">shardcache_count_items_callback_t</a></td>
<td class="fieldname">
count</td>
<td class="fielddoc">
If the index callback is set, this callback will be used to determine how many items are going to be returned in the index. <dl class="section note"><dt>Note</dt><dd>This callback is mandatory if the index callback is set, otherwise it's optional </dd>
<dd>
check <a class="el" href="shardcache_8h.html#a9d02396238920c93777e1eb2bc83dad0" title="Get the index of keys managed by the specific shardcache instance by querying the storage module...">shardcache_get_index()</a> documentation for more details </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a812eee52bcfc625300abc402441a0e53"></a><a class="el" href="shardcache__storage_8h.html#a2572426fe6ef4e4c3f3306a6e37ebd74">shardcache_thread_start_callback_t</a></td>
<td class="fieldname">
thread_start</td>
<td class="fielddoc">
Optional callback which, if set, will be called everytime a new worker thread (which could access the storage) has been created. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a6877bb9385aa83489fe0410e370e8d26"></a><a class="el" href="shardcache__storage_8h.html#a0328b13b4cd837b9c8adf61a2fcac12e">shardcache_thread_exit_callback_t</a></td>
<td class="fieldname">
thread_exit</td>
<td class="fielddoc">
Optional callback which, if set, will be called everytime a new worker thread (which could have accessed the storage) has been destroyed. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a61de0baeb4ac9201c7c0a566b0033ce3"></a>int</td>
<td class="fieldname">
global</td>
<td class="fielddoc">
If set to a non zero value, shardcache will assume that all the peers can access the same keys on the storage (for example a shared database, or a shared filesystem)) </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a20d841b529cf3ade6c1bf0ed4f54c6b4"></a>int</td>
<td class="fieldname">
shared</td>
<td class="fielddoc">
If set to a non zero value, shardcache will assume that all the replicas of a given peer can access the same storage and set commands won't be propagated to all the replicas by a receiving node. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac259b5598fd3c643774d9fae93f81f1e"></a>void *</td>
<td class="fieldname">
priv</td>
<td class="fielddoc">
Pointer to private data which will passed to all the callbacks. <dl class="section note"><dt>Note</dt><dd>The implementation can use this pointer to keep its internal data/status/handlers/whatever </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2acd0ffa2af6e02b99af787dc71d4e5a"></a>struct <a class="el" href="shardcache__storage_8h.html#struct____shardcache__storage__s_8internal">__shardcache_storage_s</a></td>
<td class="fieldname">
internal</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structshardcache__counter__t" id="structshardcache__counter__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct shardcache_counter_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Structure representing an exposed counter. </p>
<p>Any of the internal shardcache modules can export counters (as uint32_t integers) for stats purposes. Any module can add new counters which will be included in the array returned by <a class="el" href="shardcache__storage_8h.html#a075b1863d2be9c8ab1a863ea860112e2" title="Returns the list of registered counters with their actual value. ">shardcache_get_counters()</a>. The value member of the structure will be always accessed via the atomic builtins and the same is expected from the module exporting it.</p>
<dl class="section note"><dt>Note</dt><dd>A list of exported counters can be obtained using <a class="el" href="shardcache__storage_8h.html#a075b1863d2be9c8ab1a863ea860112e2" title="Returns the list of registered counters with their actual value. ">shardcache_get_counters()</a> </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a16fc0f87ad25489df80d6968315516d6"></a>char</td>
<td class="fieldname">
name[256]</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af64b565402f2865da1c40bf890df96a8"></a>uint64_t</td>
<td class="fieldname">
value</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="struct____shardcache__storage__s_8internal" id="struct____shardcache__storage__s_8internal"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct __shardcache_storage_s.internal</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae1260894f59eeae98c8440899de4df8d"></a>void *</td>
<td class="fieldname">
handle</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae37f0136aa3ffaf149b351f6a4c948e9"></a><a class="el" href="shardcache__storage_8h.html#a1b9c26308b738a1b3e576086739800ef">shardcache_storage_init_t</a></td>
<td class="fieldname">
init</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="afb14982288108e1fbd6207ef55f05027"></a><a class="el" href="shardcache__storage_8h.html#a5038a83d8a6632c7428a09f94822ec0a">shardcache_storage_destroy_t</a></td>
<td class="fieldname">
destroy</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a86266ee937d97f812a8e57d22b62ee29"></a><a class="el" href="shardcache__storage_8h.html#ae614818897fc60c8474e7722d997eb62">shardcache_storage_reset_t</a></td>
<td class="fieldname">
reset</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a133019dc2f53df8463b3c0f3d5527f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHARDCACHE_STORAGE_API_VERSION&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a77115805f2f16c71266f6ad605cfe0fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* shardcache_fetch_item_callback_t) (void *key, size_t klen, void **value, size_t *vlen, void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to provide the value for a given key. </p>
<p>The shardcache instance will call this callback if the value has not been found in the cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A valid pointer to the key </td></tr>
    <tr><td class="paramname">klen</td><td>The length of the key </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to where to store the pointer to the actual value. The caller has the responsibility to release the memory containing the value. </td></tr>
    <tr><td class="paramname">vlen</td><td>If provided the length of the returned value will be stored at the location pointed by vlen </td></tr>
    <tr><td class="paramname">priv</td><td>The 'priv' pointer previously stored in the <a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t" title="Structure holding all the callback pointers required by shardcache to interact with underlying storag...">shardcache_storage_t</a> structure at initialization time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; -1 otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned value pointer MUST be a volatile copy and the caller WILL release its resources </dd></dl>

</div>
</div>
<a class="anchor" id="a9c4f7d79c1f74accc80c3e448319b576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* shardcache_fetch_items_callback_t) (void **keys, size_t *klens, int nkeys, void **values, size_t *vlens, void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to provide values for multiple keys at once. </p>
<p>The shardcache instance will call this callback if the value has not been found in the cache for the given keys.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>A valid pointer to an array of keys </td></tr>
    <tr><td class="paramname">klens</td><td>An array containing the length of the keys </td></tr>
    <tr><td class="paramname">nkeys</td><td>The number of keys in the key array (which matches the length of the klen array) </td></tr>
    <tr><td class="paramname">values</td><td>An array where to store the pointers to the actual values (NULL if the value for one of the key was not found) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The items in the values array refer to the key at the same index in the provided input array. If the value for a given key was not found it will contain a NULL pointer. The caller is responsible of releasing the memory of all the values returned in the array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vlens</td><td>If provided the length of the returned value will be stored at the location pointed by vlen </td></tr>
    <tr><td class="paramname">priv</td><td>The 'priv' pointer previously stored in the <a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t" title="Structure holding all the callback pointers required by shardcache to interact with underlying storag...">shardcache_storage_t</a> structure at initialization time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; -1 otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned value pointers MUST be a volatile copy and the caller WILL release their resources </dd></dl>

</div>
</div>
<a class="anchor" id="a996475c853ec7e30994b9ea9171e1977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* shardcache_store_item_callback_t) (void *key, size_t klen, void *value, size_t vlen, void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to store a new value for a given key. </p>
<p>The shardcache instance will call this callback if a new value needs to be set in the underlying storage</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A valid pointer to the key </td></tr>
    <tr><td class="paramname">klen</td><td>The length of the key </td></tr>
    <tr><td class="paramname">value</td><td>A valid pointer to the value to store </td></tr>
    <tr><td class="paramname">vlen</td><td>The length of the value </td></tr>
    <tr><td class="paramname">priv</td><td>The 'priv' pointer previously stored in the <a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t" title="Structure holding all the callback pointers required by shardcache to interact with underlying storag...">shardcache_storage_t</a> structure at initialization time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, -1 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a6a0e75764a7131dc7b96a13a656be1e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* shardcache_remove_item_callback_t) (void *key, size_t klen, void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to remove an existing value for a given key. </p>
<p>The shardcache instance will call this callback if the value for a given key needs to be removed from the underlying storage</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A valid pointer to the key </td></tr>
    <tr><td class="paramname">klen</td><td>The length of the key </td></tr>
    <tr><td class="paramname">priv</td><td>The 'priv' pointer previously stored in the <a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t" title="Structure holding all the callback pointers required by shardcache to interact with underlying storag...">shardcache_storage_t</a> structure at initialization time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, -1 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a0f4d387c8442c3bc8828a30cac2fa351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* shardcache_exist_item_callback_t) (void *key, size_t klen, void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to check if a specific key exists on the storage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A valid pointer to the key </td></tr>
    <tr><td class="paramname">klen</td><td>The length of the key </td></tr>
    <tr><td class="paramname">priv</td><td>The 'priv' pointer previously stored in the <a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t" title="Structure holding all the callback pointers required by shardcache to interact with underlying storag...">shardcache_storage_t</a> structure at initialization time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if exists, 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a4334fefdfd765ed2ed3783fd930e1eaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* shardcache_count_items_callback_t) (void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback returning the number of items in the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priv</td><td>The priv pointer owned by the storage</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of items in the storage </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This callback is mandatory if the index callback is set, otherwise it's optional </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="shardcache__storage_8h.html#a72fef27941beefd884ef508f09f876ad" title="Callback to fetch the index of stored keys. ">shardcache_get_index_callback_t</a> </dd>
<dd>
<a class="el" href="shardcache_8h.html#a9d02396238920c93777e1eb2bc83dad0" title="Get the index of keys managed by the specific shardcache instance by querying the storage module...">shardcache_get_index()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a72fef27941beefd884ef508f09f876ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* shardcache_get_index_callback_t) (<a class="el" href="shardcache__storage_8h.html#structshardcache__storage__index__item__t">shardcache_storage_index_item_t</a> *index, size_t isize, void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to fetch the index of stored keys. </p>
<p>The shardcache instance will call this callback when it will need to retrieve the full index of the keys owned (and stored) by the instance</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An array of <a class="el" href="shardcache__storage_8h.html#structshardcache__storage__index__item__t" title="structure representing an item in the storage index ">shardcache_storage_index_item_t</a> structures to hold the index </td></tr>
    <tr><td class="paramname">isize</td><td>The number of slots in the provided index array </td></tr>
    <tr><td class="paramname">priv</td><td>The priv pointer owned by the storage</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items in the index, 0 if none or errors </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the caller didn't previously check the number of items via the count() callback, it MUST check if the returned value matches the passed isize and in case try again with a bigger index size to ensure there are no more items. Using the count() method ensure to get all the items which are expected to exist</dd>
<dd>
The count might change between the time the count callback returns and the this callback is called.<br />
 If this happens the cases are 2 :<br />
 1 - More items have been added in the meanwhile. Which means that the caller will get exactly the expected number of items but there will be more new items in the storage which are not returned.<br />
 2 - Some items have been removed in the meanwhile. The caller will get less items than expecting but this is not a problem because the alloc'd memory is enough and the caller will also know how many items have been actually returned by the index callback. </dd></dl>

</div>
</div>
<a class="anchor" id="a2572426fe6ef4e4c3f3306a6e37ebd74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* shardcache_thread_start_callback_t) (void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback used to notify the underlying storage about the creation of a new worker thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priv</td><td>The priv pointer owned by the storage</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of items in the storage </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This callback is mandatory if the index callback is set, otherwise it's optional </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="shardcache__storage_8h.html#a72fef27941beefd884ef508f09f876ad" title="Callback to fetch the index of stored keys. ">shardcache_get_index_callback_t</a> </dd>
<dd>
<a class="el" href="shardcache_8h.html#a9d02396238920c93777e1eb2bc83dad0" title="Get the index of keys managed by the specific shardcache instance by querying the storage module...">shardcache_get_index()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0328b13b4cd837b9c8adf61a2fcac12e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* shardcache_thread_exit_callback_t) (void *priv)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback returning the number of items in the index. </p>
<p>Callback used to notify the underlying storage about the destruction of a new worker thread</p>
<dl class="section return"><dt>Returns</dt><dd>The total number of items in the storage </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This callback is mandatory if the index callback is set, otherwise it's optional </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="shardcache__storage_8h.html#a72fef27941beefd884ef508f09f876ad" title="Callback to fetch the index of stored keys. ">shardcache_get_index_callback_t</a> </dd>
<dd>
<a class="el" href="shardcache_8h.html#a9d02396238920c93777e1eb2bc83dad0" title="Get the index of keys managed by the specific shardcache instance by querying the storage module...">shardcache_get_index()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1b9c26308b738a1b3e576086739800ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* shardcache_storage_init_t) (<a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t">shardcache_storage_t</a> *, char **)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5038a83d8a6632c7428a09f94822ec0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* shardcache_storage_destroy_t) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae614818897fc60c8474e7722d997eb62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* shardcache_storage_reset_t) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a848ddc8184ab4372f3230498bee3383e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t">shardcache_storage_t</a>*(* shardcache_storage_constructor) (const char **options)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback used to create a new instance of a storage module. </p>
<p>All storage modules need to expose this callback which will be called by the shardcache instance at initialization time to let the storage initialize and create the <a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t" title="Structure holding all the callback pointers required by shardcache to interact with underlying storag...">shardcache_storage_t</a> structure and its internals</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>A null-termianted array of strings holding the options specific to the storage module</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly initialized <a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t" title="Structure holding all the callback pointers required by shardcache to interact with underlying storag...">shardcache_storage_t</a> structure usable by the shardcache instance </dd></dl>

</div>
</div>
<a class="anchor" id="a160e6e6138d57c6b6ed3c59e1a1f2578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* shardcache_storage_destructor) (<a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t">shardcache_storage_t</a> *storage)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback used to dispose all resources associated to a previously initialized storage module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>A pointer to a valid (and previously initialized) <a class="el" href="namespace_3global_scope_4.html#structshardcache__storage__t" title="Structure holding all the callback pointers required by shardcache to interact with underlying storag...">shardcache_storage_t</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a075b1863d2be9c8ab1a863ea860112e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int shardcache_get_counters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="shardcache_8h.html#a32947f5c645e606fe2284a1c28f7fcf9">shardcache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="shardcache__storage_8h.html#structshardcache__counter__t">shardcache_counter_t</a> **&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of registered counters with their actual value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>A valid pointer to a shardcache_t structure </td></tr>
    <tr><td class="paramname">counters</td><td>A reference to a pointer which will be set to the initialized memory holding the array of counters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The counters array needs to be released using free() once not necessary anymore. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of counters contained in the counters array </dd></dl>

</div>
</div>
<a class="anchor" id="aa56ead41f7f61d7b88417fc9dc6937f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shardcache_clear_counters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="shardcache_8h.html#a32947f5c645e606fe2284a1c28f7fcf9">shardcache_t</a> *&#160;</td>
          <td class="paramname"><em>cache</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all the counters to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>A valid pointer to a shardcache_t structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<address class="footer"><small>
Generated on Tue Aug 4 2015 05:55:15 for Shardcache by <a href="http://www.doxygen.org/index.html">doxygen</a> 1.8.10
</small></address>
</body>
</html>
